var tools = [new Tool(), new Tool()]

Item.prototype.subDivide = function() {
  let len = this.segments.length
  for (var i = len - 1; i >= 0; i--) {
    this.segments[i].curve.divideAtTime(0.5)
  }
}
new Path.Circle([20, 40], 50)

new Path.Circle([20, 30], 50)

tools[0].on({
  mousedown(e) {
    this.path = new Path({
      strokeColor: "#000",
      strokeJoin: "round",
      strokeCap: "round",
      strokeWidth: 12
    })
  },
  mousedrag(e) {
    this.path.add(e.point)
  },
  mouseup(e) {
    this.path.simplify()
    this.path.subDivide()
    this.path.data.pathData = this.path.pathData

    this.path.onFrame = function(event) {
      if (event.count % 5 == 0) {
        let pos = (event.count / 200) % 1
        this.pathData = this.data.pathData
        this.position = [this.bounds.width / 2, 0]
        distortAlongPath(distortPath, this, pos)
      }
    }
  }
})

let distortPath = new Path({
  strokeColor: "blue",
  segments: [[-200, -200], [200, 200], [400, 0], [200, -200], [-200, 200], [-400, 0]],
  closed: true
})

distortPath.smooth()
distortPath.position = view.viewSize / 2

tools[0].path = new Path.Circle({ radius: 200, strokeColor: "red" })
tools[0].path.subDivide()
tools[0].path.subDivide()
tools[0].path.data.pathData = tools[0].path.pathData

tools[1].on({
  mousedown(e) {
    this.clone = tools[0].path.clone()
    this.path = new Path({ strokeColor: "blue", guide: true })
  },
  mousedrag(e) {
    this.path.add(e.point)
  },
  mouseup(e) {
    this.path.simplify()
    this.path.simplify()
    this.path.closed = true
    this.clone.position = [this.clone.bounds.width / 2, 0]

    distortAlongPath(this.path, this.clone, 0.5)
  }
})

function distortAlongPath(distortPath, sourcePath, offset) {
  let cloneWidth = sourcePath.bounds.width
  for (let seg of sourcePath.segments) {
    let normalizedX = seg.point.x / cloneWidth
    let normalizedInX = (seg.handleIn.x + seg.point.x) / cloneWidth
    let normalizedOutX = (seg.handleOut.x + seg.point.x) / cloneWidth
    let normX = (normalizedX * cloneWidth + offset * distortPath.length) % distortPath.length
    let normInX = (normalizedInX * cloneWidth + offset * distortPath.length) % distortPath.length
    let normOutX = (normalizedOutX * cloneWidth + offset * distortPath.length) % distortPath.length
    let normalAtPos = distortPath.getNormalAt(normX)
    let normalInAtPos = distortPath.getNormalAt(normInX)
    let normalOutAtPos = distortPath.getNormalAt(normOutX)
    let inY = seg.handleIn.y + seg.point.y
    let outY = seg.handleOut.y + seg.point.y
    seg.point = distortPath.getPointAt(normX) + normalAtPos * -seg.point.y
    seg.handleIn = distortPath.getPointAt(normInX) + normalInAtPos * -inY - seg.point
    seg.handleOut = distortPath.getPointAt(normOutX) + normalOutAtPos * -outY - seg.point
  }
}
